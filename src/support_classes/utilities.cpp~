#include "Utilities.h"
#include "TestBedLogger.h"
#include "WorkersCommon.h"
#include <memory>
#include <sstream>
#include <string.h>
#include <assert.h>
#include <unistd.h>
#include <fcntl.h>
#include <arpa/inet.h>
#include <cctype>
#include <algorithm>

namespace TestBed
{

int ReadRealMatrix(float **mat, const std::string file, const uint32_t numRows, const uint32_t numCols)
{
    const uint32_t bufSize = 50e6;

    FILE *f1 = fopen(file.c_str(), "r");
    if (f1 == NULL)
    {
       TB_FATAL("Unable to open file: %s",file.c_str());
       return -1;
    }

    char *buf;
    if ((buf = (char *)malloc(bufSize)) == NULL)
    {
        TB_FATAL("Failed to allocate space for buffer!");
        return -1;
    }

    if ((*mat = (float *)malloc(numRows*numCols*sizeof(float))) == NULL)
    {
        TB_FATAL("Failed to allocated space for H matrix!");
        free(buf);
        return -1;
    }

    float *cur = *mat;
    uint32_t row = 0;
    uint32_t col = 0;
    while (fgets(buf, bufSize-1, f1) != NULL)
    {
        char *tmp;

        tmp = strtok(buf, ",");
        while (tmp != NULL)
        {
            cur[row*numCols + col]     = strtof(tmp, NULL);
            tmp = strtok(NULL, ",");
            col++;
            if (col >= numCols)
                break;
        }

        col = 0;
        row++;

        if (row >= numRows)
            break;
    }

    free(buf);
    fclose(f1);

    return 0;
}

int ReadPnMatrix(float **mat, const char *file, const uint32_t numRows, const uint32_t numCols, uint32_t padSamps, uint32_t reps)
{
    const uint32_t bufSize = 1e6;
    int ret = 0;

    FILE *f1 = fopen(file, "r");
    if (f1 == NULL)
    {
       TB_FATAL("Unable to open file: %s",file);
       return -1;
    }

    char *realBuf;
    if ((realBuf = (char *)malloc(bufSize)) == NULL)
    {
        TB_FATAL("Failed to allocated space for buffer!");
        return -1;
    }

    if ((*mat = (float *)calloc(numRows*(numCols*reps+padSamps)*2*sizeof(float), 1)) == NULL)
    {
        TB_FATAL("Failed to allocated space for PN matrix!");
        free(realBuf);
        return -1;
    }

    float *cur = *mat;

    /* Set alternating +-1 padding samples in real parts. */
    for (uint32_t row = 0; row < numRows; row++)
    {
        for (uint32_t i = 0; i < padSamps; i++)
            cur[row*2*(numCols*reps+padSamps) + i*2] = 1.0 - 2*(i%2);
    }

    char *p1;
    uint32_t row = 0;
    uint32_t col = 0;
    uint32_t pnCnt;
    while (fgets(realBuf, bufSize-1, f1) != NULL)
    {
        char *rTmp;
        rTmp = strtok_r(realBuf, ",", &p1);

        while (rTmp != NULL)
        {
            for (pnCnt = 0; pnCnt < reps; pnCnt++)
            {
                uint32_t index = 2*(row*(numCols*reps+padSamps) + padSamps + pnCnt*numCols) + col;
                cur[index] = strtof(rTmp, NULL);
            }
            rTmp = strtok_r(NULL, ",", &p1);

            col += 2;
            if (col >= (numCols*reps+padSamps)*2)
                break;
        }

        col = 0;

        row++;

        if (row >= numRows)
            break;
    }

    free(realBuf);
    fclose(f1);

    return ret;
}

int ReadComplexMatrix(float **mat, const char *realFile, const char *imagFile, const uint32_t numRows, const uint32_t numCols, bool alloc)
{
    const uint32_t bufSize = 4e6;
    int ret = 0;

    FILE *f1 = fopen(realFile, "r");
    if (f1 == NULL)
    {
       TB_FATAL("Unable to open file: %s",realFile);
       return -1;
    }

    FILE *f2 = fopen(imagFile, "r");
    if (f2 == NULL)
    {
       TB_FATAL("Unable to open file: %s",imagFile);
       fclose(f1);
       return -1;
    }


    char *realBuf, *imagBuf;
    if ((realBuf = (char *)malloc(bufSize)) == NULL)
    {
        TB_FATAL("Failed to allocated space for buffer!");
        fclose(f1);
        fclose(f2);
        return -1;
    }

    if ((imagBuf = (char *)malloc(bufSize)) == NULL)
    {
        TB_FATAL("Failed to allocated space for buffer!");
        free(realBuf);
        fclose(f1);
        fclose(f2);
        return -1;
    }

    if (alloc)
    {
        if ((*mat = (float *)malloc(numRows*numCols*sizeof(float)*2)) == NULL)
        {
            TB_FATAL("Failed to allocated space for H matrix!");
            free(realBuf);
            free(imagBuf);
            fclose(f1);
            fclose(f2);
            return -1;
       }
    }

    float *cur = *mat;
    char *p1, *p2;
    uint32_t row = 0;
    uint32_t col = 0;
    while (fgets(realBuf, bufSize-1, f1) != NULL)
    {
        char *rTmp, *iTmp;
        if (fgets(imagBuf, bufSize-1, f2) == NULL)
        {
            TB_FATAL("Imaginary file is not the same size as real!");
            ret = -1;
            break;
        }

        rTmp = strtok_r(realBuf, ",", &p1);
        iTmp = strtok_r(imagBuf, ",", &p2);

        while (rTmp != NULL)
        {
            cur[row*numCols*2 + col]     = strtof(rTmp, NULL);
            cur[row*numCols*2 + col + 1] = strtof(iTmp, NULL);

            rTmp = strtok_r(NULL, ",", &p1);
            iTmp = strtok_r(NULL, ",", &p2);

            col += 2;
            if (col >= numCols*2)
                break;
        }

        col = 0;
        row++;

        if (row >= numRows)
            break;
    }


    free(realBuf);
    free(imagBuf);
    fclose(f1);
    fclose(f2);

    return ret;
}

// Read in file containing combined real+image values
int ReadComplexMatrix(Complex64 **mat, const char *complexFile, const uint32_t numRows, const uint32_t numCols, const uint32_t numBands, bool alloc)
{
    const uint32_t bufSize = 4e6;
    int ret = 0;

    FILE *f1 = fopen(complexFile, "r");
    if (f1 == NULL)
    {
       TB_FATAL("Unable to open file: %s",complexFile);
       return -1;
    }

    char *cplxBuf;
    if ((cplxBuf = (char *)malloc(bufSize)) == NULL)
    {
        TB_FATAL("Failed to allocated space for buffer!");
        fclose(f1);
        return -1;
    }

    if (alloc)
    {
        if ((*mat = (Complex64 *)malloc(numRows*numCols*numBands*sizeof(Complex64))) == NULL)
        {
            TB_FATAL("Failed to allocated space for matrix!");
            free(cplxBuf);
            fclose(f1);
            return -1;
       }
    }

    float *cur = reinterpret_cast<float*>(*mat);
    uint32_t row = 0;
    uint32_t col = 0;
    uint32_t band = 0;
    while (fgets(cplxBuf, bufSize-1, f1) != NULL)
    {
      char *cTmp, *p1;
      cTmp = strtok_r(cplxBuf, ",", &p1);
      uint32_t offset = (band*numRows + row)*(numCols*2);
      while (cTmp != NULL)
      {
        float real = 0, imag = 0;
        char sep = '\0', tail = '\0';
        std::stringstream s(cTmp);
        s >> real >> sep >> imag >> tail;
        switch(sep){
          case '+': break;
          case '-': imag = -imag; break;
          case 'i': imag = real; real = 0; break;
          case '\0': imag = 0; break;
          default:
            TB_FATAL("Value %s not valid complex form", cTmp);
            ret -1;
        }

        cur[offset + col]     = real;
        cur[offset + col + 1] = imag;

        cTmp = strtok_r(NULL, ",", &p1);

        col += 2;
        if (col >= numCols*2)
            break;
      }

      col = 0;

      row++;
      if (row >= numRows) {
        row = 0;

        band++;
        if (band >= numBands)
          break;
      }
    }

    free(cplxBuf);
    fclose(f1);

    return ret;
}

int ReadComplexMatrixRow(float *x, const char *fn_real, const char *fn_imag, int which_row, int columns)
{
   FILE *fp;
   char *filename;
   float *xp;
   //char *line;
   //size_t slen;
   //ssize_t llen;
   int ret,r,c;

   for (int files=0; files<2; files++)
   {
      //line = NULL;
      //slen = 0;
      if (files == 0)
      {
         filename = (char*)fn_real;
         xp = x;
      }
      else
      {
         filename = (char*)fn_imag;
         xp = &x[1];
      }

      TB_DEBUG("File %d: %s which_row=%d columns=%d",files,filename,which_row,columns);

      fp = fopen(filename,"r");
      if (fp == NULL)
      {
         assert(0 && "Unable to read file");
      }
      //for (r=0; r<which_row; r++)
      //{
      //   TB_DEBUG("skipping line %d",r);
      //   llen = getline(&line,&slen,fp);
      //   assert((llen != -1) && "failed to parse line");
      //}
      //if (which_row > 0) free(line);

      for (r=0; r<which_row; r++)
      {
         float value;
         for (c=0; c<columns; c++)
         {
            ret = fscanf(fp,"%f,",&value);
            assert((ret == 1) && "failed to parse line");
         }
      }

      for (int c=0; c<columns; c++)
      {
         ret = fscanf(fp,"%f,",&xp[2*c]);
         assert((ret == 1) && "failed to parse line");
         //TB_DEBUG("%s:v[%d,%d]=%f",filename,which_row,c,xp[2*c]);
      }
      fclose(fp);
   }
}

int PrepareCorrelation(Complex64 **h_buf, const Complex64 *in, uint32_t len, int32_t lag)
{
    *h_buf = static_cast<Complex64 *>(calloc(sizeof(Complex64)*len*(lag*2+1), 1));

    if (h_buf == NULL)
    {
        TB_ERROR("Failed to allocate buffer!\n");
        return -1;
    }

    Complex64 *cur = *h_buf;
    for (int32_t i = -lag; i <= lag; i++)
    {
        int32_t srcOffset = i < 0 ? -i : 0;
        int32_t dstOffset = i < 0 ? 0 : i;
        memcpy(cur + dstOffset, in + srcOffset, (len-abs(i))*sizeof(Complex64));
        cur += len;
    }
    return 0;
}

int ReadBinarySampleFile(char **h_buf, const char *filename, int rows, int columns, int samp_size, bool alloc)
{
   int ret;
   int samp_size_bytes = samp_size/8;
   if (alloc)
   {
      if ((*h_buf = (char *)malloc(rows*columns*samp_size_bytes)) == NULL)
      {
         TB_FATAL("Failed to allocated space for samples");
         return -1;
      }
   }

   int fd = open(filename, O_RDONLY);
   if (fd < 0)
   {
      TB_FATAL("Failed to open filename: %s",filename);
      if (alloc)
      {
         free(*h_buf);
      }
      return -1;
   }
   ret = read(fd, reinterpret_cast<void *>(*h_buf), rows*columns*samp_size_bytes);
   close(fd);
   if (ret != rows*columns*samp_size_bytes)
   {
      return -1;
   }
   return 0;
}

double ConvertTimespecToMilliseconds(struct timespec &t)
{
   return static_cast<double>(t.tv_sec)*1000.0 + static_cast<double>(t.tv_nsec)/1000000.0;
}

//! Take one IP and MAC addresses and create a single AddrInfo object
//! This object is used to define stream source and/or destination address
AddrInfo* BuildAddrList(uint32_t ip, uint8_t mac[], uint16_t port)
{
    AddrInfo *addrList = new AddrInfo[1];
    addrList->m_udpPort = htons(port);
    memcpy(addrList->m_macAddr, mac, sizeof(addrList->m_macAddr));
    addrList->m_ipAddr = ip;

    return addrList;
}


//! Take one IP and MAC addresses and create a single AddrInfo object
//! This object is used to define stream source and/or destination address
AddrInfo* BuildAddrList(std::string &ip, std::string &mac, uint16_t port)
{
    AddrInfo *addrList = new AddrInfo[1];
    addrList->m_udpPort = htons(port);
    MacToBytes(addrList->m_macAddr, mac.c_str());
    if (inet_pton(AF_INET, ip.c_str(), &addrList->m_ipAddr) != 1)
    {
        TB_FATAL("Failed to convert IP address %s to numeric form", ip.c_str());
    }

    return addrList;
}

//! Take a list of IP and MAC addresses and create a list of AddrInfo objects
//! These ojects are then used to define stream source and destination address
AddrInfo *BuildAddrList(std::vector<std::string> &ips, std::vector<std::string> &macs, uint16_t port)
{
    int num = std::min(ips.size(), macs.size());

    AddrInfo *addrList = new AddrInfo[num];

    for (auto i = 0 ; i < num ; i++) {

      addrList[i].m_udpPort = htons(port);
      MacToBytes(addrList[i].m_macAddr, macs[i].c_str());
      if (inet_pton(AF_INET, ips[i].c_str(), &addrList[i].m_ipAddr) != 1)
      {
          TB_FATAL("Failed to convert IP address %s to numeric form", ips[i].c_str());
      }
    }

    return addrList;
}

//! Take a list of IP and MAC addresses and create a list of AddrInfo objects
//! These ojects are then used to define stream source and destination address
TxStreamDestList *BuildDestList(std::vector<std::string> &ips, std::vector<std::string> &macs, uint16_t port)
{
    int num = std::min(ips.size(), macs.size());

    TxStreamDestList *addrList = (TxStreamDestList*)calloc(num, sizeof(TxStreamDestList));

    for (auto i = 0 ; i < num ; i++) {
      TxStreamDestList *tsdl = addrList + i;

      tsdl->m_dstAddrs = 1;
      tsdl->m_dstAddrList = BuildAddrList(ips[i], macs[i], port);
    }

    return addrList;
}

//! Take a list of IP and MAC addresses and create a list of TxStreamDestList objects
//! These ojects are then used to define stream destinations that contain multiple ports
TxStreamDestList *BuildDestList(int out_streams, std::vector<std::vector<std::string>> &tx_ips, std::vector<std::vector<std::string>> &tx_macs, uint16_t port)
{
   int num_dsts = tx_ips.size();
   if (out_streams != num_dsts) {
      TB_FATAL("%u out stream configured, but only %u dst specified",
        out_streams, num_dsts);
      return nullptr;
   }
   if (num_dsts != tx_macs.size()) {
      TB_FATAL("IP and MAC Tx Destination sizes do no match");
      return nullptr;
   }

   TxStreamDestList *tx_dst = (TxStreamDestList*)calloc(out_streams, sizeof(TxStreamDestList));
   for (auto j = 0; j < out_streams; j++)
   {
      TxStreamDestList *tsdl = tx_dst + j;
      tsdl->m_dstAddrs = tx_ips[j].size();
      if (tsdl->m_dstAddrs != tx_macs[j].size()) {
          TB_FATAL("Inconsistent bonded port definition, user %u has %lu IPs and %lu MACS",
                   j, tx_ips[j].size(), tx_macs[j].size());
          free(tx_dst);
          return nullptr;
      }
      tsdl->m_dstAddrList = BuildAddrList(tx_ips[j], tx_macs[j], port);
      if (tsdl->m_dstAddrList == nullptr) {
          TB_FATAL("Failed to convert user %u addresses to numeric form", j);
          free(tx_dst);
          return nullptr;
      }
   }
   return tx_dst;
}

std::string str_toupper(std::string s)
{
   std::transform(s.begin(), s.end(), s.begin(),
      // static_cast<int(*)(int)>(std::toupper)         // wrong
      // [](int c){ return std::toupper(c); }           // wrong
      // [](char c){ return std::toupper(c); }          // wrong
      [](unsigned char c){ return std::toupper(c); }    // correct
   );
   return s;
}

};  // namespace TestBed
